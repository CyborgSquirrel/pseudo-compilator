#import "@preview/lovelace:0.2.0": *
#import "@preview/fletcher:0.4.4" as fletcher
#import "@preview/cetz:0.2.2"
#import "style.typ": code_block

#show: setup-lovelace

#set page(
  margin: (left: 80pt, right: 80pt),
)
#set heading(numbering: "1.1")
#set text(size: 12pt)
#set block(spacing: 1.5em)
#set image(width: 90%)

#show figure.where(
  kind: "code",
): set figure(supplement: "Code listing")
#show figure.where(
  kind: "error",
): set figure(supplement: "Error sample")

#show heading.where(level: 1): it => [
  #pagebreak(weak: true)
  #block(height: 60pt)
  #set text(size: 24pt)

  #let count = counter(heading)
  #if it.numbering != none [
    Chapter #count.display()
    #linebreak()
    #linebreak()
    #it.body
  ] else [
    #it.body
  ]
  #linebreak()
  #linebreak()
]

#let todo(msg) = {
  [#text(fill: red, weight: "bold", size: 12pt)[(TODO: #msg)]]
}

#show figure: set block(breakable: true)

#let raw_highlight = state("raw_highlight", true)
#show raw: it => {
  if it.block {
    set par(justify: false)
    set align(left)
    context if raw_highlight.get() {
      code_block(it)
    } else {
      it
    }
  } else {
    // it
    context if raw_highlight.get() {
      highlight(fill: luma(210), radius: 0pt, extent: 1pt, it)
    } else {
      it
    }
  }
}

/*

state of the art: Antlr
- ce mai exista in domeniul limbajelor educationale

alte limbaje similare:
- https://www.99-bottles-of-beer.net/lyrics.html

educational programming languages
- https://en.wikipedia.org/wiki/List_of_educational_programming_languages
- https://www.computerscience.org/resources/best-programming-languages-for-kids/
- https://www.eduporium.com/blog/eduporium-weekly-5-programming-languages-students-could-be-learning/

*/

#include "cover.typ"

// leave a blank page
#pagebreak()
#pagebreak()

#set par(justify: true)

// reset page numbering
#set page(
  numbering: "i",
)
#counter(page).update(1)

// Abstract: un rezumat în limba engleză cu prezentarea, pe scurt, a conținutului pe capitole, punând accent pe contribuțiile proprii și originalitate

#[
  #set align(center)
  #set par(justify: false)
  
  *Abstract*

  This thesis presents the design and implementation of a compiler for the Pseudocode programming language, which is utilized in Romanian high-school Computer Science education and the Romanian Computer Science Baccalaureate exam. The primary objective is to enhance the efficiency and accuracy of verifying Pseudocode programs, thereby benefiting students, educators, and exam graders. The compiler employs LLVM as a backend, transforming Pseudocode into optimized machine code. Key features include an accessible online editor and debugging support. The performance of the executables generated by the compiler is evaluated through various benchmarks. Future work aims to further improve the compiler's usability and extend its feature set.
]


#pagebreak(weak: true)

#outline(indent: 32pt)

#pagebreak(weak: true)

// reset page numbering
#set page(
  numbering: "1",
)
#counter(page).update(1)

= Introduction

This work details the implementation of a compiler for the Pseudocode programming language, together with the requisite theoretical concepts. Here, "Pseudocode" is in reference to the programming language that is part of Romanian high-school level Computer Science education, and the Romanian Computer Science Baccalaureate exam.

In this work, "Pseudocode" (capitalized) will refer to the aforementioned meaning, whereas "pseudocode" (non-capitalized) will be used with the common definition: "a notation resembling a simplified programming language, used in program design"@oxford2023pseudocode.

The primary motivation for the development of this work is to decrease the effort and time investment which is presently required for rigorous verification of Pseudocode programs. This benefits Romanian pupils, teachers, and exam graders alike. Pupils may find it easier to check their work, to discover errors, and to repair said errors, whereas teachers and exam graders may experience a decrease in their workload.

== Pseudocode

When high-school pupils are initially introduced to computer science in Romania, the first programming language they learn is "Pseudocode". As the name suggests, "Pseudocode" is supposed to be a simple language, suitable for learning basic programming, and introductory algorithms.

#figure(
  kind: "code",
  caption: [Pseudocode],
)[
  ```
  citește x
  i ← 2
  ┌cât timp i*i ≤ x execută
  │	┌dacă x % i = 0 atunci
  │	│	scrie i
  │	│	┌dacă i ≠ x/i atunci
  │	│	│	scrie x/i
  │	│	└■
  │	└■
  │	i ← i+1
  └■
  ```
] <baccalaureate_pseudocode>

While this language is not as emphasized in the middle years of high school, it returns in the final year. The Pseudocode language is a significant part of the Computer Science Baccalaureate exam. Students that choose to take this exam necessarily spend a lot of time with the language, as they study and prepare.

Presently, the only viable way for a Pseudocode program to be executed on a computer, is for it to first be manually translated into a compilable/interpretable programming language (e.g., Python, C++, Java), and only then executed, using the chosen language's toolchain. This process is not only tedious, but also error prone. An implementation of Pseudocode can save people's time, while increasing the rigor of the educational system.

== Impact Estimation

The Romanian Baccalaureate comprises a series of 3-4 written exams, which mark the completion of high-school level studies in Romania. One of these exams is in Romanian Language and Literature; this exam is mandatory for everyone. Another is in the compulsory subject of the profile, which the pupil has taken; this exam can be either in mathematics or history.

A third exam is in a subject of the pupil's choosing, but which is relevant to that pupil's profile. For example, pupils whose profile is "Theoretical: Sciences", may choose one of the following subjects: Computer Science, Physics, Biology, or Chemistry.

In 2023, 130,522 Romanian high-school pupils took the Baccalaureate exam. Of those pupils, 32.7% were eligible to take the computer science exam (@can_cs). Of the pupils that were eligible to take the computer science exam, 20.39% chose to do so (@could_cs_but_took). This comes out to 8708 pupils taking the computer science exam, that would have been directly impacted by this work, in the year 2023.

#{
  let total = 130522;
  let can_info = 42689;
  
  let data = (
    (align(center)[*eligible* to take\ CS exam]  , can_info),
    (align(center)[*ineligible* to take\ CS exam], total - can_info),
  )
  let sum = data.map(value => value.at(1)).sum()

  [
    #figure(
      caption: [pupils eligible and ineligible to take Computer Science exam, 2023],
      cetz.canvas({
        cetz.chart.piechart(
          data,
          value-key: 1,
          label-key: 0,
          radius: 3,
          outset: 2,
          slice-style: gradient.linear(red, blue, green, yellow),
          outer-label: (radius: 130%),
          inner-label: (content: (value, label) => [
            #(calc.floor((value/sum)*10000) / 100)%
            ], radius: 140%
          ),
        )
      })
    ) <can_cs>
  ]
}

#{
  let data = (
    (align(center)[Biology]          , 25396),
    (align(center)[Physics]          , 5103 ),
    (align(center)[Computer\ Science], 8708 ),
    (align(center)[Chemistry]        , 3482 ),
  )
  let sum = data.map(value => value.at(1)).sum()

  [
    #figure(
      caption: [subjects chosen by pupils eligible to take Computer Science, 2023],
      cetz.canvas({
        cetz.chart.piechart(
          data,
          value-key: 1,
          label-key: 0,
          radius: 3,
          outset: 2,
          slice-style: gradient.linear(red, blue, green, yellow),
          outer-label: (radius: 130%),
          inner-label: (content: (value, label) => [
            #(calc.floor((value/sum)*10000) / 100)%
            ], radius: 140%
          ),
        )
      })
    ) <could_cs_but_took>
  ]
}

== Summary of sections

In @sota previous work in the domain of educational programming languages is recounted, and compared to this work. @theory goes over a series of relevant theoretical and technical concepts, including a description of the Pseudocode language. @app describes the implementation of a Pseudocode compiler, consisting of a parser, and a backend which generates LLVM IR. Additionally, an implementation of an online Pseudocode editor is offered, which aims to be accessible to high-school pupils. @evaluation mainly compares the performance of Pseudocode to industry-standard programming languages. @discussion presents advantages and disadvantages of the implemented system, as well as suggestions for future work. In @conclusions the author's final thoughts are presented.

== Use of generative AI tools

#[
  #set text(style: "italic")
  During the development of this work, the author used ChatGPT to improve the flow and clarity of the text. After having used this service, the author revised and edited the generated content. The author assumes responsibility for the content of this work.
]

= State of the art <sota>

// - Prezentare sisteme, algoritmi, abordări asemănătoare sau înrudite cu subiectul lucrării
// - Detalii despre sistemele existente, cu discutarea avantajelor/dezavantajelor în general şi în relaţie cu abordarea lucrării

== Educational programming languages

Educational programming languages aim to assist and encourage people to learn programming and computing concepts. Frequently, though not always, the languages are designed with a particular audience in mind. The concepts that they introduce can be narrow (e.g., the fundamentals of functional programming), as well as broad (e.g., game development with 2D sprites). What follows is an enumeration of such educational programming languages, which have been considered relevant to this work.

=== Scratch

Scratch@maloney2010scratch is a programming environment that is primarily aimed at introducing children aged 8-16 to coding. Scratch's appeal and success comes from its focus on enabling novice programmers to easily develop interactive, media-rich projects.

Developing such projects in an industry-standard language would be quite difficult for a novice, as they would need to learn and become acquainted with a significant amount of new concepts: programming language syntax, interfacing with audio, video, and input devices using external libraries, possibly having to compile source code, etc.. With their underlying programming environment and the outward facing visual editor (@scratch_online_editor), Scratch can achieve almost the same result, but with a significantly lower upfront cost.

// - It's an excellent introduction to programming, however it is not an optimal environment to learn to learn more complex aspects of computer science, such as various algorithms.

#figure(image("res/scratch.png"), caption: [Scratch's online visual editor]) <scratch_online_editor>

=== Racket

// Scheme copy, to which various features were gradually added

Racket@felleisen2015racket is a programming language and environment that was borne out of a desire to improve programming education. The language originally started out as a copy of Scheme; gradually, features were added to make it better suited to the authors' needs: a syntax extension system, mechanisms for creating safe abstractions, etc.. The Racket environment also includes an IDE (@racket_ide), with modern features such as syntax highlighting, and debugging. While Racket was designed to be easily approachable for novices, it is mature enough to be suitable for industry use.

An intriguing feature of Racket is its "language levels". It allows for only a subset of the language to be enabled at a given moment. This permits, for example, for a programming course to start students on a simplified version of Racket, with fewer features being enabled, and for increasingly advanced features to be enabled as the course progresses.

#figure(image("res/racket_ide.png"), caption: [Racket's IDE@drracket_environment]) <racket_ide>

=== Python

Python is an industry programming language, whose educational potential was recognized as early as 2012@kruglyk2012choosing. The syntax is intuitive and easy to learn, the type system is forgiving, as the language is dynamically typed. In addition to this is Python's renown for possessing a wealth of easily installable packages, which enable users to develop complex projects, ranging from GUI applications to web servers.

// However, the author believes that Python is not an optimal language for use cases such as standardized testing. Despite the language's outward simplicity, in reality it possesses a large set of features, which is constantly being expanded with updates. It would be unreasonable to ask of all test graders to learn the entirety of Python, and to regularly learn the newest features. But it would also be inconvenient to limit students to writing only a particular version of Python, or to only use a particular set of features.

== Pseudocode

/*

points in favor of Pseudocode:
- governments are slow to adopt new tech, for instance Python
  => we'll be stuck with this Pseudocode for a while longer
  => it's worthwile improving the UX of the current Pseudocode
- existing industry-standard languages are complex, are being constantly updated, and can usually be enhanced with an ever-expanding number of downloadable packages
  => it may lead to confusion for pupils during tests (why implement a sorting algorithm manually, when you can just do list.sort())
  => or it could even confuse teachers or test graders, if a pupil happens to use a feature from a newer version of the language, which they haven't acquainted themselves with
  => it's useful to have a barebones language that doesn't receive constant updates, for the purposes of testing

*/

The Pseudocode programming language does not appear to possess an official specification, nor an implementation. It is targeted at a specific audience -- high-school level pupils in Romania, and it accomplishes a precise goal -- teaching the basics of imperative computer programming, together with some algorithms.

This work takes inspiration from educational programming languages' focus on convenience and approachability. The online editor which has been implemented (@online_editor) takes after Scratch's visual editor, and Racket's IDE. The syntax of the language was influenced by Python.

/*

1. Pseudocode has advantages for examination, being a fixed and simple language
2. governments adopt new technology slowly

*/

Having gone over a number of educational programming languages raises the following question: why develop another language, Pseudocode, considering that so many mature educational languages already exist? The justification is twofold.

First, Pseudocode is better suited for examination purposes, i.e. the Romanian Computer Science Baccalaureate exam. This is a consequence of it being a simple language, with a limited set of features, which does not ever change, and can be quickly learned in its entirety. On the other hand, the aforementioned languages are either constantly receiving updates, or only practically usable on a computer.

The reason why it is undesirable for a language to constantly receive updates, is because it either forces all exam graders to keep up with the stream of updates, lest they misunderstand a section of code which employs a new feature, and lower a pupil's grade; or otherwise, the language has to be restricted to a particular subset of features, which could be difficult to practically implement in a written exam.

Second, it is commonly accepted that governments tend to change and adopt new technology at a slow pace. This means that even if, for example, it was discovered that a particular programming language significantly improved pupils' outcomes in education, it is not guaranteed when or if it would be adopted in the educational system.

Taking these considerations into account, improving the Pseudocode developer experience by creating compilers, debuggers, editors, and other tools is a valid approach to support Romanian high-school students in their computer science education.

= Theory <theory>

// - Prezintare aspectelor teoretice (algoritmi, arhitecturi, etc) folosite în lucrare sau din care e inspirată abordarea lucrării
// - Se pot prezenta şi tehnologii/framework-uri mai interesante folosite în teză, dar în niciun caz tehnologii comune, cum ar fi php/javascript/java/.net/etc

== Shunting yard algorithm <theory_shunting_yard>

#let shunting_infix_footnote = footnote[
  The algorithm accepts all valid infix expressions, as well as some expressions which are not in infix form.
]

The shunting yard algorithm is a method for parsing infix expressions#shunting_infix_footnote, first described by Edsger Dijkstra in 1961@dijkstrashunting. The following is an overview and description of the algorithm's function.

The algorithm expects to receive an expression as input; it should be possible for this expression to be split into a list of tokens. Let's consider that each token can belong to one of the following three categories: `operand` (e.g., `42`, `x`), `operator` (e.g., `+`, `*`), and `paren` (e.g., `(`, `)`). Let's also consider that every `operator` has a certain precedence value, and that operators with higher precedence bind stronger.

Next, it is necessary to describe the $"apply"$ function. This function computes the result of applying an operation to a pair of operands, for instance applying adddition could be defined as $"apply"("+", a, b)=a+b$. The formal definition of the function is: $"apply":"Operator" times "Operand" times "Operand" -> "Operand"$.

The outline of the algorithm is as follows: the tokens comprising the input expression are iterated, while manipulating an `output` queue, and an `operators` stack. If the current token is an `operand`, it is added to the `output` queue. If it is a left parenthesis, it is pushed onto the `operators` stack.

If the current token is an `operator`, then the following procedure will be performed in a loop: a pair of operands, $"operand"_1$ and $"operand"_0$ are extracted from the `output` queue, an $"operator"$ is popped from the `operators` stack, and the result of $"apply"("operator", "operand"_0, "operand"_1)$ is added back into the `output` queue. This process is repeated, as long as the topmost operator's precedence is greater than the current token's precedence. When the loop finished, the current token is pushed onto the `operators` stack.

When a right parenthesis is encountered, a similar process is carried out, however with some differences: the loop only repeats as long as the topmost operator is not a left parenthesis, the right parenthesis is not added to the `operators` stack, and its matching left parenthesis must be popped from the stack.

After all the expression's tokens have been iterated, a similar procedure is carried out once again, with some differences: the loop stops only when the operators stack has been emptied, and this time there is no token which should be pushed onto the `operators` stack.

At the end, the `output` stack must contain a single operand, and this operand is the final output of the shunting yard algorithm.

A pseudocode version of the algorithm is offered in @shunting_yard_code. In this implementation, `out` is the `output` queue, and `ops` is the `operators` stack.

#algorithm(
  caption: [Shunting yard algorithm],
  pseudocode(
    no-number, [*input:* expression],
    no-number, [*output:* result of parsing the expression (e.g., a number, an AST)],
    [out $<-$ queue()],
    [ops $<-$ stack()],
    [*for* token *in* expression.tokens() *do*], ind,
      [*if* token.type() $=$ "operand" *then*], ind,
        [out.enqueue(token)],
      ded,
      [*if* token.type() $=$ "operator" *then*], ind,
        [*while* ops.len() $>$ 0 *and* ops.top() $!=$ "(" *and* token.precedence() $<$ ops.top().precedence() *do*], ind,
          [operator $<-$ ops.pop()],
          [operand#sub()[1] $<-$ out.dequeue()],
          [operand#sub()[0] $<-$ out.dequeue()],
          [out.enqueue(apply(operator, operand#sub()[0], operand#sub()[1]))],
        ded,
        [ops.push(token)],
      ded,
      [*if* token $=$ "(" *then*], ind,
        [ops.push(token)],
      ded,
      [*if* token $=$ ")" *then*], ind,
        [*while* ops.len() $>$ 0 *and* ops.top() $!=$ "(" *do*], ind,
          [operator $<-$ ops.pop()],
          [operand#sub()[1] $<-$ out.dequeue()],
          [operand#sub()[0] $<-$ out.dequeue()],
          [out.enqueue(apply(operator, operand#sub()[0], operand#sub()[1]))],
        ded,
        [ops.pop()],
      ded,
    ded,
    [*while* ops.len() $>=$ 1], ind,
      [operator $<-$ ops.pop()],
      [*assert* operator $!=$ "("],
      [operand#sub()[1] $<-$ out.dequeue()],
      [operand#sub()[0] $<-$ out.dequeue()],
      [out.enqueue(apply(operator, operand#sub()[0], operand#sub()[1]))],
    ded,
    [*assert* ops.len() $=$ 0],
    [*assert* out.len() $=$ 1],
    [result $<-$ out.dequeue()],
    [*return* result],
  )
) <shunting_yard_code>

== LLVM <theory_llvm>

The LLVM Project is a collection of modular and reusable compiler and toolchain technologies@llvminfrastructure.

Underpinning much of the project is LLVM Intermediate Representation, commonly referred to as LLVM IR. Put shortly, LLVM IR is a high-level assembly language. It does not directly expose CPU registers; instead it is an SSA, or static single assignment form, meaning that it consists of variable assignments, where each variable is assigned to exactly once.

Many of the programming languages that target machine code can be cleanly made to target LLVM IR. Some examples are: C and C++ (`clang` compiler), Rust, Swift, Haskell, Zig, among others.

LLVM's libraries expose procedures for constructing LLVM IR, optimizing it, and converting it to an object or executable file, supporting a wide range of target platforms. Emitting LLVM IR allows a compiler developer to focus on improving and polishing their language, while having the time-consuming process of writing routines for optimization and machine code generation handled by LLVM.

#let clang_version_footnote = footnote[`clang` version #read("llvm_example/target/clang_version.txt").trim() was used.]

For an example of LLVM IR, compiling the C program in @llvm_simple_c_program with `clang`#clang_version_footnote, LLVM's C compiler, produces the LLVM IR at @llvm_simple_c_program_ll.

#figure(kind: "code", caption: [Simple C program])[
  #raw(read("llvm_example/main.c"), lang: "c", block: true)
] <llvm_simple_c_program>

#[
  #show raw: set text(size: 8pt)
  #figure(kind: "code", caption: [LLVM IR generated for @llvm_simple_c_program])[
    #raw(read("llvm_example/target/main.ll"), lang: "ll", block: true)
  ] <llvm_simple_c_program_ll>
]

== Language Server Protocol <theory_lsp>

The Language Server Protocol's (LSP) primary goal, is to decouple the program that analyzes source code, and implements code editing features such as: symbol renaming, auto-complete, go to definition, etc., i.e. the language server, from the text editor, i.e. the language server's client.

Instead of every editor having to implement intricate analysis logic for every programming language that it desires to support, it is sufficient to support the Language Server Protocol, for it to be able to provide the IDE features that users expect today.

Language server implementations exist for most of the programming languages which are actively used today: C, C++, TypeScript, Python, etc..

== CodeMirror <codemirror>

#let codemirror_repo_footnote = footnote[Accessible at https://github.com/codemirror/dev/.]

CodeMirror#codemirror_repo_footnote is a modern, robust, and extensible text editor library, that is created for the web. It is implemented on top of the comparatively simple building blocks provided by web standards, e.g., the `<textarea>` element, the event handling systems.

CodeMirror supports syntax highlighting, customizable keybindings, as well as extensions which bring features such as LSP support. It exposes a rich and flexible API, allowing for the editor to be custom-fit to specific use-cases.

#figure(image("res/codemirror.png"), caption: [JavaScript source code in CodeMirror editor])

== DWARF format <dwarf_format>

#let dwarf_acronym_footnote = footnote[DWARF is an acronym for "Debugging With Arbitrary Record Formats".]

DWARF#dwarf_acronym_footnote is a standardized format@dwarfstandard for embedding debugging metadata into an executable. It encodes various information which is helpful for debugging purposes, for example: mappings between source code lines and machine code instructions, mappings between a stack address, and the corresponding variable's name, type, and source line on which it was declared, etc..

Structurally, DWARF metadata consists of Debugging Information Entries, or DIEs@dwarfstandard[Section 2.1]. Each DIE is defined by a tag name (e.g., `DW_TAG_subprogram`, `DW_TAG_variable`), and a set of attributes. The attributes@dwarfstandard[Section 2.2] store various information which is relevant to their tag, for example: the source line from which a particular DIE was generated (`DW_AT_decl_line`), the name of the variable, type, or function that the DIE is describing (`DW_AT_name`), etc..

Each DIE may optionally have a list of child DIEs@dwarfstandard[Section 2.3], which gives the metadata a tree structure. Child DIEs can serve various purposes, including but not limited to, defining the members of a struct (`DW_TAG_member`), or the variables declared in a function (`DW_TAG_variable`).

@dwarf_simple_c_program_dwarf is an example of DWARF metadata generated for the program in @dwarf_simple_c_program.

#figure(kind: "code", caption: [Simple C Program])[
  #raw(read("./dwarf_example/main.c"), block: true, lang: "c")
] <dwarf_simple_c_program>

#figure(kind: "code", caption: [DWARF metadata generated for @dwarf_simple_c_program])[
  #show raw: set text(size: 8pt)
  #raw(read("./dwarf_example/target/dwarf-processed"), block: true)
] <dwarf_simple_c_program_dwarf>

The DWARF format is supported by an extensive list of compilers (e.g. the GNU Compiler Collection, the LLVM compiler suite) and debuggers (e.g., the GNU Debugger `gdb`, the LLVM Debugger `lldb`). If one is writing a compiler, and desires for it to produce a debuggable executable, emitting DWARF metadata is an effective way to achieve this goal.

== Pseudocode language

This section outlines the syntax and properties of the Pseudocode language which has been implemented as part of this work. This language is similar, but not the same, as the language used in Romanian computer science education, which will be referred to as "Baccalaureate Pseudocode". Most of the changes serve the goal of making the language easier to type on a keyboard. Some of the principal differences between Baccalaureate Pseudocode and Pseudocode can be observed in @baccalaureate_vs_mine.

While Baccalaureate Pseudocode relies on box-drawing characters to delimit code blocks, the version developed in this work uses indentation, similar to the Python language. Characters such as `←` and `≤` (among others) are approximated with easier to type alternatives, `<-` and `<=` respectively.

#figure(
  kind: "code",
  caption: [structurally equivalent Baccalaureate Pseudocode (left) and Pseudocode (right)],
)[
  #box(
    columns(2)[
      ```
      citește x
      i ← 2
      ┌cât timp i*i ≤ x execută
      │	┌dacă x % i = 0 atunci
      │	│	scrie i
      │	│	┌dacă i ≠ x/i atunci
      │	│	│	scrie x/i
      │	│	└■
      │	└■
      │	i ← i+1
      └■
      ```
      #colbreak()
      ```
      citește x
      i <- 2
      cât timp i*i <= x execută
      	dacă x % i = 0 atunci
      		scrie i
      		dacă i != x/i atunci
      			scrie x/i
      	i <- i+1
      ```
    ]
  )
] <baccalaureate_vs_mine>

The paradigm that best describes Pseudocode is imperative programming. The language supports the most common control-flow structures: if-else statements, while loops, for loops, repeat ... until loops. It does not support user-defined functions nor classes.

In Baccalaureate Pseudocode, all variables are floating point numbers. The Pseudocode implemented in this work expands the language slightly, by introducing an additional type, lists of floating point numbers (further described in @lists_section). Lists-adjacent functionality may be disabled, so that the compiler will more closely match Baccalaureate Pseudocode.

=== Syntax

==== Operations

@pseudocode_operations lists all the operations present in Pseudocode, with their description, precedence (higher binds stronger), type of input and output values, and arity.

Most of the operations are common to all modern programming languages. There are two that stand out, however: `[x]` which computes the whole part of `x` (e.g., `[3.14] = 3`), and `x|y` which checks whether `x` divides `y` (e.g., `3|6` is true, but `3|7` is false).

#raw_highlight.update(false)
#figure(
  caption: [pseudocode operations],
  table(
    columns: (auto, auto, auto, auto, auto, auto),
    [*Operation*], [*Description*], [*Precedence*], [*Input*], [*Output*], [*Arity*],
    [`[x]`], [whole part], [7], [float], [float], [unary],
    [`+x`], [identity], [7], [float], [float], [unary],
    [`-x`], [negation], [7], [float], [float], [unary],
    [`x*y`], [multiplication], [6], [float], [float], [binary],
    [`x/y`], [division], [6], [float], [float], [binary],
    [`x%y`], [remainder], [6], [float], [float], [binary],
    [`x+y`], [addition], [5], [float], [float], [binary],
    [`x-y`], [subtraction], [5], [float], [float], [binary],
    [`x=y`], [check equality], [4], [float], [bool], [binary],
    [`x!=y`], [check inequality], [4], [float], [bool], [binary],
    [`x<y`], [check less-than], [4], [float], [bool], [binary],
    [`x>y`], [check greater-than], [4], [float], [bool], [binary],
    [`x<=y`], [check less-than or equal], [4], [float], [bool], [binary],
    [`x>=y`], [check greater-than or equal], [4], [float], [bool], [binary],
    [`x|y`], [check `x` divides `y`], [4], [float], [bool], [binary],
    [`x și y`], [logical "and"], [3], [bool], [bool], [binary],
    [`x sau y`], [logical "or"], [2], [bool], [bool], [binary],
  )
) <pseudocode_operations>
#raw_highlight.update(true)

==== Statements

Assignment is denoted with `{variable} <- {value}`, and swapping of two variables with `{left} <-> {right}` (@assignment_swap). Console input and output is achieved with `citește {variable}` and `scrie {value}` respectively (@citeste_scrie).

#figure(kind: "code", caption: [variable assignment and swapping])[
```
x <- 1
y <- 2
x <-> y
```] <assignment_swap>

#figure(kind: "code", caption: [console input and output])[
```
citește x
scrie "x=", x
```] <citeste_scrie>

If-else statements are denoted with `dacă {condition} atunci ... altfel ...` (@if_else), while loops with `cât timp {condition} execută ...` (@while), repeat ... until loops with `repetă ... până când {condition}` (@repeat_until), and for loops with `pentru i<-{start},{stop},{increment} execută ...` (@for).

#figure(kind: "code", caption: [if-else statement])[
```
x <- 10
dacă x < 5 atunci
  scrie "x<5"
altfel
  scrie "x>=5"
```] <if_else>

#figure(kind: "code", caption: [while loop])[
```
x <- 0
cât timp x < 10 execută
  x <- x+1
```] <while>

#figure(kind: "code", caption: [repeat ... until loop])[
```
x <- 10
repetă
  x <- x-1
până când x <= 0
```] <repeat_until>

#figure(kind: "code", caption: [for loop; specifying an increment is optional, and its default value is 1])[
```
pentru i <- 1,10,2 execută
  scrie i

pentru i <- 1,10 execută
  scrie i
```] <for>

==== Lists <lists_section>

List syntax and behavior was developed as part of this work, and is not part of Baccalaureate Pseudocode. The decision to implement lists was motivated by the desire to enable pupils to study a wider variety of algorithms (e.g., list sorting), using the already mostly familiar syntax of Pseudocode.

A list variable can be defined using `{variable} <- {value0}, {value1}, ...`, and an empty list uses the special syntax of `{variable} <- ,`. Lists can be indexed using square brackets, i.e. `list[{index}]`, and a list's length can be determined using the `lungime(list)` built-in function. Values may be inserted into lists using `inserează list,{index},{value}`, and removed using `șterge list,{index}`.

All the aforementioned syntax is demonstrated in @lists_example andd @lists_example_two.

#figure(kind: "code", caption: [creating a list; getting the list's length; getting and setting elements of a list])[
```
list <- 1,2,3,4,5
pentru i<-0,lungime(list)-1 execută
  list[i] <- list[i]+1
  scrie list[i]
```] <lists_example>

#figure(kind: "code", caption: [creating an empty list; inserting elements into, and removing elements from the list])[
```
list <- ,
pentru i<-1,10 execută
	inserează list,i-1,i
cât timp lungime(list) > 0 execută
	șterge list,lungime(list)-1
```] <lists_example_two>

==== EBNF Grammar <ebnf_grammar>

#let regex_help_footnote = footnote[
  The regular expression syntax is Rust-flavored. Hence, `\d` matches any digit, `\w` matches any word character (including any unicode letter, and also digits), and `\W` matches any non-word character.
]

#raw_highlight.update(false)

@ebnf_grammar_fig describes the grammar of the Pseudocode language in Extended Backus-Naur Form. `INDENT` and `DEDENT` are special symbols, signifying an increase and decrease in indentation level by one, respectively. The rest of the symbols are defined in @regexes_for_symbols.

#figure(
  caption: [regular expressions for symbols],
  table(
    columns: (auto, auto, auto),
    [*Symbol*    ] , [*Regular Expression*#regex_help_footnote] , [*Description*         ] ,
    [`ID`        ] , [`[^\d\W][\w]*`     ] , [identifier            ] ,
    [`FLOAT_LIT` ] , [`\d+(\.\d*)?`      ] , [floating-point literal] ,
    [`STRING_LIT`] , [`"[^"]*"`          ] , [string literal        ] ,
    [`CHAR_LIT`  ] , [`'.'`              ] , [character literal     ] ,
    [`NEWLINE`   ] , [`\n`               ] , [newline               ] ,
  )
) <regexes_for_symbols>
#raw_highlight.update(true)

#figure(caption: [grammar of Pseudocode language in EBNF])[
  #set align(left)
  #raw_highlight.update(false)
  #include "grammar.typ"
  #raw_highlight.update(true)
] <ebnf_grammar_fig>

=== Sample programs

Despite being a comparatively simple language, Pseudocode posesses enough complexity to support the implementation of algorithms which are relevant to pupils' education. Two sample programs are presented to illustrate this: @bubble_sort_implementation performs bubble sort on a list of numbers, and @sin_x_implementation computes $sin(x)$ using Taylor expansion.

#figure(kind: "code", caption: [bubble sort implementation in Pseudocode])[
```
list <- 53, 34, 12, 665, 34, 23, 54, 65, 123, 65

pentru i<-0,lungime(list)-1-1 executa
	pentru j<-0,lungime(list)-i-1-1 executa
		daca list[j] > list[j+1] atunci
			list[j] <-> list[j+1]

pentru i<-0,lungime(list)-1 executa
	scrie list[i]
``` ] <bubble_sort_implementation>

#figure(kind: "code", caption: [approximation of $sin(x)$ by way of Taylor expansion, implemented in Pseudocode])[
```
citește x
gata <- 0
r <- 0
t <- x
n <- 1
cât timp gata = 0 execută
	r <- r + t
	
	s <- -1 * ((x*x) / ((2*n)*(2*n+1))) * t
	dacă s = t atunci
		gata <- 1
	t <- s
	n <- n + 1
scrie r
```] <sin_x_implementation>


= Application <app>

== Compiler implementation

/*

Why use Rust?
- memory safety beneficial to parser implementation; don't need to copy strings over and over
- strong type system
- sum types Option<> and Result<> <3 help while hand-writing parser

-? compiled => performance

*/

The Rust programming language was chosen for the implementation of the compiler. This decision was made based on a number of Rust's features, which were deemed to be desirable for this task.

First, Rust's strong memory safety guarantees allow for safe and performant manipulation of strings, without needing to resort to excessive copying. This benefits the implementation of the parser, which involves a significant amount of string processing.

Second, Rust's type system helps improve the code structure, and to catch and prevent bugs, especially in a large codebase. This contributes toward ensuring the correctness of the code, which is paramount in a compiler.

Third, sum types, which are present in the Rust language, significantly aided certain parts of the implementation. Parsing was made easier by `Option<>` and `Result<>`, AST nodes could be conveniently defined and represented using sum types, etc..

=== Parsing

The entire source file is parsed in a single pass, using a hand-written parser, without any tokenization being performed beforehand. The primary reason for this decision, is that the parsing of some tokens is context-sensitive. For instance, the combination of characters `<-` could be tokenized either as a `LEFT_ARROW`, or as a `LESS_THAN` and `MINUS`, depending on the source code that precedes it. This ambiguity can be seen in @tokenizing_ambiguity.

#figure(
  kind: "code",
  caption: [tokenization of `<-` is context-sensitive],
)[
  #box(
    columns(2)[
      ```
      a <- 42
      ```
      #colbreak(weak: true)
      ```
      dacă a<-42 atunci
        scrie "Salut, Lume!"
      ```
    ]
  )
] <tokenizing_ambiguity>

Other aspects of the Pseudocode language, namely its use of indentation for code blocks, as well as the presence of spaces in some of its keywords (e.g., `cât timp`, `până când`), also influenced the decision to hand-write the parser.

==== Error messages

#let labelled_block = (label_, block_) => [
  #block(fill: luma(210), inset: (top: 4pt), radius: 4pt)[
    #set align(left)
    #block(inset: (left: 4pt, right: 4pt))[
      #label_
    ]
    #block_
  ]
]

#let error_sample = (code, error) => [
  #set block(spacing: 4pt)
  #box(
    columns(2)[
      #labelled_block[Code][
        #code
      ]
      #colbreak()
      #labelled_block[Error][
        #error
      ]
    ]
  )
]

Error messages can be considered the user interface of a compiler. Their purpose is to assist developers with transitioning their program from an invalid state into a valid one. They appear to play an especially important role for novice programmers: it takes fewer tries for them to bring their program into a valid state, when they're using a compiler which produces higher quality error messages@becker2016effective.

The desire for the compiler to produce good error messages was another factor that contributed to the decision of hand-writing the parser. The additional flexibility that a hand-written parser affords, allows for the cause of an error to be more accurately determined, which in turn leads to better error messages.

In the implementation, when a parsing error is encountered, compilation is completely halted. Thereafter, a message specifying the error, along with the line and column on which it occurred, is emitted.

The rest of this section will present a few sample error messages, along with the source code that produced them. The sample error messages will be accompanied by comments, pointing out noteworthy design decisions, implementation details, etc..

@daca_assignment presents a case where an error message could be enhanced, thanks to the parser being hand-written. According to the grammar (@ebnf_grammar), "dacă" should be followed by a boolean expression.

In this specific case, however, it is clear that the user was trying to assign the value 41 to a variable named "dacă". If the compiler merely produced an error stating that it had failed to parse a boolean expression, it would be of little help for users trying to resolve the issue.

The parser possesses special-case code to handle such situations gracefully, by checking whether the user is trying to assign a value to a keyword.

#figure(kind: "error")[
  #error_sample[
    ```
    dacă <- 41
    ```
  ][
    ```
    [1:7] Eroare la parsare: nume de variabilă nevalid „dacă”.
    ```
  ]
] <daca_assignment>

When a left parenthesis is missing its matching right parenthesis (@lparen_without_rparen), or a right parenthesis is missing its matching left parenthesis (@rparen_without_lparen), the compiler helpfully indicates the location of the parenthesis in question, aiding the user with locating and resolving the issue.

#figure(kind: "error")[
  #error_sample[
    ```
    scrie (40+1
    ```
  ][
    ```
    [1:6] Eroare la parsare: paranteza stângă nu are paranteză dreaptă corespunzătoare.

    ```
  ]
] <lparen_without_rparen>

#figure(kind: "error")[
  #error_sample[
    ```
    scrie 40+1)
    ```
  ][
    ```
    [1:10] Eroare la parsare: paranteza dreaptă nu are paranteză stângă corespunzătoare.

    ```
  ]
] <rparen_without_lparen>

Despite the language being dynamically typed, some type errors can be checked at compile-time, as can be observed in @wrong_type_bool and @wrong_type_number.

#figure(kind: "error")[
  #error_sample[
    ```
    daca 41 atunci
    	scrie "da!"
    ```
  ][
    ```
    [1:5] Eroare la parsare: tipul acestei valori ar fi trebuit să fie unul dintre următoarele: o condiție.
    ```
  ]
] <wrong_type_bool>

#figure(kind: "error")[
  #error_sample[
    ```
    x <- 41 + (1 = 1)
    ```
  ][
    ```
    [1:10] Eroare la parsare: tipul acestei valori ar fi trebuit să fie unul dintre următoarele: un număr.
    ```
  ]
] <wrong_type_number>

==== Parsing technique

Most of the parsing is done in an "incremental" style, i.e. using small functions, where each function parses a specific element of the syntax: an ident, a "dacă" statement, an arrow, etc..

Expressions are parsed using an altered version of the shunting yard algorithm (@theory_shunting_yard). Where the unaltered version accepts all infix expressions (e.g., `1 + 2`), as well as some expressions which are not infix (e.g., `1 2 +`), the altered version only accepts infix expressions.

This was accomplished by introducing a variable that keeps track of the types of tokens that the parser expects to encounter next. In the beginning an operand is expected; after an operand is read, an operator is expected, and so on. If the parser encounters a token that does not match its expectations, an error is thrown. This alteration ensures the parser accepts only valid infix expressions, while rejecting sequences such as `1 2 +`.

==== Abstract Syntax Tree

Parsing @code_sample_for_ast produces an AST resembling the one in @generated_ast (with minor simplifications for clarity and brevity).

#figure(kind: "code", caption: [simple code sample])[```
citește x
scrie "Am citit: ", x
dacă x > 42 atunci
  scrie "da!"
```] <code_sample_for_ast>

#figure(caption: [AST (slightly simplified) generated for @code_sample_for_ast])[
  #{
    let data = (
      [Root],
      ([Citeste], ([Float\ Lvalue], ([Ident], [`"x"`]))),
      ([Scrie],
        ([String\ Literal], [`"Am citit: "`]),
        ([Rvalue], ([Float\ Rvalue], ([Ident], [`"x"`]))),
      ),
      ([DacaAtunciAltfel],
        ([Condition],
          [Gt],
          ([Float\ Rvalue], ([Ident], [`"x"`])),
          ([Float\ Rvalue], ([Literal], [`42`]))
        ),
        ([AtunciBranch],
          ([Scrie],
            ([String\ Literal], [`"da!"`]),
          ),
        )
      ),
    )
    cetz.canvas(length: 50pt, {
      cetz.tree.tree(
        data,
        draw-edge: (from, to, ..) => {
          cetz.draw.line(from, to, stroke: 0.75pt)
        },
        spread: 1.3,
        draw-node: (node, ..) => {
          cetz.draw.content(
            (),
            pad(rest: 2pt, align(center, node.content)),
          )
        },
      )
    })
  }
] <generated_ast>

==== Treatment of diacritics

To ease the process of writing Pseudocode programs, the parser considers diacritics in keywords to be optional. Diacritics are symbols placed above or below a character, for example: the comma in "ș", the breve in "ă", or the circumflex in "â". Both code samples in @optional_diacritics will produce the same AST.

#figure(
  kind: "code",
  caption: [diacritics in keywords are optional],
)[
  #box(
    columns(2)[
      ```
      citește x
      cât timp x > 0 execută
        x <- x-1
      ```
      #colbreak()
      ```
      citeste x
      cat timp x > 0 executa
        x <- x-1
      ```
    ]
  )
] <optional_diacritics>

=== Compilation

#let inkwell_footnote = footnote[More specifically, Inkwell (https://github.com/TheDan64/inkwell), a Rust wrapper over the LLVM C library, was used.]

LLVM (@theory_llvm) was chosen for implementing the compiler's backend#inkwell_footnote. Hence, it is responsible for optimizing the source code, and translating it into machine code.

Once the parsing process is finished, it outputs an AST of the entire program. This AST is recursively traversed, and converted to LLVM IR. Once the conversion is complete, the IR is optimized, and used to generate an object file. Subsequently, the `clang` command is used to link the object file with system libraries (e.g., `libc`, `libm`), and with `libpseudo_sys`, a library which was purpose-built to implement features of the Pseudocode language. The end result is an executable file.

The `libpseudo_sys` library primarily exposes procedures that manipulate lists: creating a list, cloning it, freeing its memory, getting, setting, inserting, and removing elements, as well as retrieving its length.

==== Floating-point number equality comparison

One issue that arises when the only numeric type is floating-point numbers, is verifying whether two numbers are equal. An experienced programmer will know to use an $epsilon$ threshold value, and to perform a comparison between two floating-point numbers $x$ and $y$ using a formula such as $abs(x-y)<epsilon$.

However Pseudocode is not aimed at experienced programmers. On the contrary, it is supposed to assist high-school students, who have just started to learn to program. Taking this into consideration, the compiler was made to always automatically generate an epsilon-thresholded check, when an equality comparison is performed.

==== Variables <var_disc_union>

At any particular point in a program's execution, a variable may have one of two possible types: either a floating point number, or a list of floating point numbers. There is a number of ways in which such behavior can be implemented.

In this work, a "discriminated union" approach was taken. Variables are represented by structs, which are composed of two fields: a discriminator enum, and a union over all the possible values the variable could take. A version of such a data structure, implemented in Rust pseudocode, is offered in @var_disc_union_pseudocode.

#figure(kind: "code", caption: [structure of discriminated union, described with Rust pseudocode])[
```rust
enum Discriminator {
	Float,
	List,
}
union Variant {
	float: f64,
	list: List,
}
struct Variable {
	kind: Discriminator,
	variant: Variant,
}
```] <var_disc_union_pseudocode>

At runtime, the type of a value can be determined by inspecting its discriminator. When necessary, type checks can be generated, by comparing the discriminant with the expected type, and throwing an error in case it does not match (such as can be observed in @wrong_type_runtime).

#figure(kind: "error", caption: [Runtime type error])[
  #error_sample[
    ```
    list <- ,
    x <- list+1
    ```
  ][
    ```
    [2:5] Eroare: valoarea are tipul „număr”, însă ar fi trebuit să fi avut tipul „listă”.
    ```
  ]
] <wrong_type_runtime>

==== Debug metadata

As it generates LLVM IR, the compiler also annotates it with debugging metadata. The metadata includes details such as: mapping from line of source code to line of generated LLVM IR, the names and types of variables, etc.. This metadata enables LLVM to generate and embed DWARF (@dwarf_format) debugging information into the object file it generates. This allows for the final executable to be debugged at source level, using any debugger that supports the DWARF format.

To permit for the compiler to generate debug metadata matching source code lines to generated LLVM IR, it is necessary for some of the nodes in the AST to be annotated with the source line of code which generated them. This information is computed and included into the nodes during the parsing process.

An example of a Pseudocode executable being debugged using the `gdbgui` debugger is presented in @debug_start. The debugger utilizes the DWARF metadata, to display the current line of source code (instead of displaying the current machine code instruction), in addition to showing the local variables, and their values.

One noteworthy aspect which can be observed in @debug_start, is that the user must manually determine which variant of a variable is the one that is currently active, based on the discriminant. This is undesirable, as it is unintuitive, introduces additional work, and is error-prone. Discriminated union annotations are supported by DWARF, and by LLVM's underlying implementation, however LLVM's C library, on which the compiler depends, unfortunately does not expose this functionality.

// 170% scaling

#figure(image("./res/debug_start.png"), caption: [Pseudocode executable loaded in `gdbgui` debugger]) <debug_start>

After loading an executable in a debugger, the user may inspect the values of variables, and step through the code.

#figure(image("./res/debug_progress.png"), caption: [stepping through the executable from @debug_start]) <debug_progress>

=== Compiler interface

The compiler is invoked from the command line. Parameters such as the program source file, the path to which the compiler's output will be written, the optimization level, etc. are all specified with command-line arguments.

#figure(
  kind: "code",
  caption: [compiling the `program.pseudo` source file into the `program` executable, using the compiler's command-line interface],
)[
  ```sh
  pseudo-cli \
    --lib-path $PATH_TO_LIBPSEUDO_SYS_SO \
    --opt default \
    ./program.pseudo --executable ./program
  ```
]

== Accessible online editor <online_editor>

Having to invoke the compiler from the command-line would deter and prevent a significant amount of novices from actually using Pseudocode. It would also present potential distribution challenges; the compiler and its installer would have to be thoroughly tested and reliably packaged for the Windows operating system.

On the other hand, a specialized online Pseudocode editor would be free of such issues. It could wrap the compiler in a sleek, simple interface, perfectly understandable by novices. It would also resolve the potential distribution problems, as the compiler would only have to function on a predetermined set of servers, which would be running a single operating system, whose state would be known.

Taking into account the aforementioned considerations, the decision was made to implement such an online editor for Pseudocode.

=== Architecture

#{
  let fe = (0,1);
  let be_job = (2,0);
  let be_job_status = (2,1);
  let be = (4,1);
  let cmp = (3,3);
  let exe = (4,3);
  figure(
    fletcher.diagram(
      spacing: 2em,
  
      fletcher.node(fe, [Frontend], stroke: 1pt),
      fletcher.node(be_job, [HTTP POST `/job`], stroke: 1pt),
      fletcher.node(be_job_status, [WebSocket `/job/{job_id}/status`], stroke: 1pt),
      fletcher.node(be, [Backend], stroke: 1pt),
      fletcher.node(cmp, [Compiler], stroke: 1pt),
      fletcher.node(exe, [Executable<asd>], stroke: 1pt),

      fletcher.edge(fe, "r,u,r", "->", shift: (-5pt, 0)),
      fletcher.edge(fe, "rr", "<->", shift: (0, 0pt)),

      fletcher.edge(be_job, "r,d,r", shift: (0, -5pt)),
      fletcher.edge(be_job_status, "rr", shift: (0, 0pt)),

      fletcher.edge(be, "d,l,d", "<->", shift: (5pt, 0)),
      fletcher.edge(be, "dd", "<->", shift: (0pt, 0)),
      fletcher.edge(cmp, exe, "=>"),
    ),
    caption: [architecture of the online editor],
  )
}

The editor consists of a frontend and backend component. The frontend is a web page containing a pair of stacked panels: a code editor, followed by an output "terminal"; it also contains buttons for running the code that has been written, for stopping the executable that is currently running, as well as a settings menu. This component was implemented using React, and the CodeMirror (@codemirror) library, which provided the implementation of the text editor.

The backend is an HTTP server written in Python. This server receives code sent by the frontend, compiles it, runs the resulting executable, and monitors the running process. As long as the process has not stopped, the backend proxies the communication between it and the frontend, through a WebSocket. That is, everything the process writes to standard output is sent through the socket, and everything the frontend sends to the socket is written to the process' standard input.

#let prlimit_footnote = footnote[
  This was achieved using the `prlimit` Linux command.
]

As the editor is meant to be released to and used by the public, it is necessary for it to limit the resources afforded to the code that it executes. Otherwise, a few `while (true) { ... }` type programs could quickly consume the server's entire capacity, while achieving little. To combat this, the server imposes configurable CPU time and memory limits on users' programs#prlimit_footnote.

=== Showcase

In @editor_running, a small program has been written, and is running. The user can communicate with it, using the input at the bottom of the console.

// 170% scaling

#figure(caption: [running a program in the editor])[#image("res/editor_running.png")] <editor_running>

Once the program has finished running, no further input may be sent.

#figure(caption: [program has finished running])[#image("res/editor_done.png")] <editor_done>

If the code which has been submitted by the user for execution happens to contain an error, the relevant source code line is highlighted (@editor_error).

#figure(caption: [error reporting within the editor])[#image("res/editor_error.png")] <editor_error>

The editor's settings window permits for users to easily toggle between using, and not using, the lists feature of the compiler (@editor_settings).

#figure(caption: [editor settings])[#image("res/editor_settings.png")] <editor_settings>

= Evaluation <evaluation>

== Compiler benchmarks

To measure the performance of the executable files produced by the compiler, and compare it to the performance achieved by industry-standard programming languages, a benchmark suite was written. A set of common programming tasks were chosen, and programs performing these tasks were written in Pseudocode, C, and Python. The language implementations which were benchmarked, along with other noteworthy details, are presented in @bench_language_versions.

#figure[
  #table(
    columns: (auto, 2fr, 4fr),
    [*Programming\ Language*], [*Version*], [*Notes*],
    [Pseudocode], [Pseudocode compiler developed as part of this work], [LLVM's default level of optimization was requested, by passing the `--opt default` argument to the compiler],
    [C], [Clang version 17.0.6], [A moderate level of optimization was requested, by passing the `-O2` argument to the compiler],
    [Python], [CPython 3.11.8], [-],
  )
] <bench_language_versions>

#let rss_size_footnote = footnote[
  Resident set size is the size of non-swapped physical memory that a process is using@ps. In this case, it can be interpreted as total memory usage, since the system on which the benchmarks were performed had sufficient memory for swapping to not be necessary.
]

The benchmarks were performed as follows: each program was executed on the same computer, for 5 consecutive times. After every execution, the output was verified to be correct. For every execution, the CPU time and maximum resident set size#rss_size_footnote (RSS) were recorded using the `time` Linux command. The final CPU time and RSS for each program was taken to be the mean of all 5 executions.

The results of the benchmarks are presented in @bench_cpu_time and @bench_rss.

#{
  let results = json("performance_comparison/results.json")

  let labels = results.values().map(a => a.keys()).flatten().dedup();
  
  let data_cpu_time_s = results.pairs().map(pair => {
    let key = pair.at(0)
    let values = ()
    for label in labels {
      values.push(pair.at(1).at(label).cpu_time_s)
    }
    return (key,) + values
  })

  let data_rss_kb = results.pairs().map(pair => {
    let key = pair.at(0)
    let values = ()
    for label in labels {
      values.push(pair.at(1).at(label).resident_set_size_kb)
    }
    return (key,) + values
  })

  [
    #figure(caption: [CPU time taken to execute the benchmarked programs])[
      #cetz.canvas({
        cetz.draw.set-style(legend: (fill: white))
        cetz.chart.barchart(
          mode: "clustered",
          size: (10, auto),
          label-key: 0,
          value-key: (..range(1, 1+labels.len())),
          x-tick-step: 0.5,
          x-label: [CPU time (seconds)],
          data_cpu_time_s,
          labels: labels,
          legend: "legend.north-east",
        )
      })
    ] <bench_cpu_time>
  ]

  [
    #figure(caption: [maximum resident set size of benchmarked programs])[
      #cetz.canvas({
        cetz.draw.set-style(legend: (fill: white))
        cetz.chart.barchart(
          mode: "clustered",
          size: (10, auto),
          label-key: 0,
          value-key: (..range(1, 1+labels.len())),
          x-tick-step: 5000,
          x-label: [resident set size (KB)],
          data_rss_kb,
          labels: labels,
          legend: "legend.north-east",
        )
      })
    ] <bench_rss>
  ]
}

For both of the recorded metrics, Pseudocode placed in the middle, with C being first, and Python last. The author suspects that Pseudocode's results for the CPU time metric were significantly impacted by it being dynamically typed. Always needing to check a variable's type, and whether it is set or not, impacts the performance, and increases the size of the executable. This issue could be improved with static analysis.

On the whole, Pseudocode demonstrates a sufficient level of performance, to be fit for educational purposes.

== Compiler tests

The compiler possesses a moderately sized test suite, achieving a line coverage of 82.22%. A functional testing approach was taken. That is, the tests verify whether particular features of the compiler work as expected, i.e., that a certain source code snippet produces a specific error, that a program which is compiled and executed produces a certain result, etc..

== Editor backend load testing

The editor backend's capacity to prevent misuse of the host machine's resources was tested. The testing was performed as follows: 100 compilation and execution requests were sent to the backend concurrently. For each request, one of three possible source code snippets was chosen, with equal probability. One of the snippets was benign (@benign_snippet), another sought to use excessive CPU resources (@cpu_snippet), and a third sought to use excessive memory resources (@memory_snippet).

#figure(kind: "code", caption: [benign code snippet])[
  ```
  pentru i<-1,10 executa
    scrie "ok"
  ```
] <benign_snippet>

#figure(kind: "code", caption: [code snippet using excessive CPU resources])[
  ```
  cat timp 1=1 executa
    scrie "ok"
  ```
] <cpu_snippet>

#figure(kind: "code", caption: [code snippet using excessive memory resources])[
  ```
  list <- ,
  cat timp 1=1 executa
    insereaza list,lungime(list),1
  ```
] <memory_snippet>

#let gnome_system_monitor_footnote = footnote[
  Host machine CPU and memory usage was captured using GNOME System Monitor.
]

As can be observed in @backend_cpu and @backend_mem#gnome_system_monitor_footnote, the test was successfully passed. The CPU usage spikes while the backend is processing the requests, but eventually returns to baseline. The memory usage appears to remain constant. Hence, the backend permitted for benign programs to execute until completion, while halting programs that sought to consume excessive resources.

#figure(caption: [host machine's CPU usage; a total of 12 logical cores were available])[
  #set image(width: 100%)
  #box(stroke: black)[
    #image("res/backend_cpu.png")
  ]
] <backend_cpu>

#figure(caption: [host machine's memory usage; a total of 64GB of memory was available])[
  #set image(width: 100%)
  #box(stroke: black)[
    #image("res/backend_mem.png")
  ]
] <backend_mem>

= Discussion <discussion>

// Discuţia rezultatelor cu accent pe aspectele positive, negative şi (dacă e cazul) inexplicabile

The systems implemented in this work achieve the goal which was set out at the beginning: transforming Pseudocode from a "static" programming language, that may only be executed through mental simulation, or manual translation into another language, into a "dynamic", compilable and executable programming language.

#let compiler_wasm_footnote = footnote[
  Unless, of course, an additional backend is written for the compiler, which does not depend on LLVM.
]

The compiler is able to produce fast and debuggable executables thanks to LLVM. On the other hand, due to its dependence on LLVM, it is excluded from being able to be executed in a browser, by being first compiled to WebAssembly#compiler_wasm_footnote. This means that the online Pseudocode editor implemented in this work can only function with the presence of an external server, which handles compilation and execution of programs. This necessarily results in increased latency, while also incurring server maintenance and scaling costs.

While the compiler's strongly-typed AST presents certain advantages, such as being able to ensure that the compiler's source code attains a certain level of correctness, it occasionally also results in deeply nested, repetitive, and difficult to understand code. It is possible that the aforementioned issues could be remediated, if the AST was not as strongly typed.

== Future work

=== Deployment

The Pseudocode editor should be deployed onto a cloud server with a publically accessible URL, so that users may easily visit it to write, compile, and execute Pseudocode. All things considered, the system should be ready for public release: the principal features have been implemented, together with safeguards which should prevent the server from failing, in case it is made to execute particularly resource-intensive programs.

=== Syntax highlighting <syntax_highlighting>

#let lezer_footnote = footnote[Accessible at https://lezer.codemirror.net/.]

Syntax highlighting would be a useful and desirable feature for the online editor. There is a number of ways in which it could be implemented. A specialized parser could be generated using Lezer#lezer_footnote, CodeMirror's own parser generator tool. Or a TextMate@textmate[Section 12] grammar could be written, which is a common approach for implementing syntax highlighting today.

Alternatively, a potentially easier way may exist. If indentation is ignored, it turns out that Pseudocode parsing is line independent; that is, if a particular line of code is modified, the outcome of parsing any other line is unaffected. Hence, the parser implemented in this work could be adapted to process singular lines. Thereafter, sufficiently efficient syntax highlighting could be achieved, by only reparsing source code lines that are edited by the user.

Thereafter, this system would be compiled to WebAssembly, and integrated with CodeMirror (@codemirror).

=== LSP server <lsp_server>

#let lsp_server_footnote = footnote[
  The `lsp_server` crate (https://github.com/rust-lang/rust-analyzer/tree/master/lib/lsp-server), which is used in Rust's own LSP server implementation, `rust-analyzer`.
]

Implementing an LSP (@theory_lsp) server for Pseudocode would greatly improve the developer experience, by bringing desirable features such as auto-complete and go-to definition.

On the one hand, Rust possesses a performant and well-tested module that implements the server side of the Language Server Protocol#lsp_server_footnote. This should greatly aid the implementation of an LSP server.

On the other hand, the compiler developed as part of this work could be ill-suited as a foundation for an LSP server. An LSP server must typically correctly and efficiently handle code that is in a partially invalid state. However, the compiler written as part of this work halts immediately when it encounters an error, parses code straight from beginning to end, and uses a somewhat rigid AST structure. It could be possible to adapt it into an LSP server, but a better option may just be to write one from scratch.

As CodeMirror (@codemirror) possesses an LSP client extension, the editor written as part of this work would also be able to benefit from LSP features.

=== Editor plugin

A code editor plugin would be another way in which Pseudocode could be made more accessible to users. It appears that novices tend to prefer Integrated Development Environments@dillon2009environment, due to their productivity enhancing features.

The future work directions presented in @syntax_highlighting and @lsp_server would lay the groundwork for the development of such a plugin. Additionally, it would be necessary to resolve the problem of packaging and distributing the compiler, together with its dependencies, to various platforms.

=== Improved error messages

The compiler presently only outputs the starting line and column of the source code that has caused an error to occur. It would be preferable, and more informative, if the compiler was able to highlight the entire span of code that caused the error, not merely where it started. The Rust compiler successfuly implements such error highlighting (@rust_error).

#figure(kind: "error")[
  #error_sample[
    ```rust
    fn main() {
    	let for = 12;
    }
    ```
  ][
    ```
    error: expected identifier, found keyword `for`
     --> test.rs:2:6
      |
    2 |     let for = 12;
      |         ^^^ expected identifier, found keyword
      |
    help: escape `for` to use it as an identifier
      |
    2 |     let r#for = 12;
      |         ++

    error: aborting due to previous error
    ```
  ]
] <rust_error>

Even better, the error handling could be further improved, so as to be able to highlight multiple spans of code, which may have led to an error. This would greatly benefit the "mismatched parentheses" error, by allowing both parentheses that caused the error to occur to be highlighted (@mismatched_parens_error).

#figure(kind: "error")[
  #error_sample[
    ```
    scrie [40+1)
    ```
  ][
    ```
    [1:11] Eroare la parsare: parantezele nu corespund.
    ```
  ]
] <mismatched_parens_error>

Since error messages are typically designed and written by a compiler developer, they run the risk of using overly-precise and technical language, which is likely to confuse novices who are not familiar with the theory and terminology@marceau2011mind. Hence, it would be beneficial for the error messages to be experienced and tested by users, and ultimately better adapted to their needs.

=== Execution of Pseudocode from a photo

#let ocr_footnote = footnote[
  For example, Google's Cloud Vision API (https://cloud.google.com/vision/docs/handwriting) can extract handwriting from an image.
]

Presently, Pseudocode is most commonly written with pen and paper. Although transcribing source code onto a computer should not be a particularly time consuming process, it could potentially be entirely automated, with the use of OCR software#ocr_footnote. This could be integrated into a system where a picture of source code is taken, then automatically converted to text, compiled, and executed.

It would also perhaps be possible to develop an OCR system which would be fine-tuned for recognizing handwritten Pseudocode source code, as it typically has a noticeably distinctive form.

=== Assess impact of compiler use on academic performance

The system developed as part of this work could well be used to study whether it is more effective for pupils to learn computer science by hand-writing programs, and mentally simulating their execution, as opposed to writing programs on a computer, and letting it execute them.

The study could be conducted as follows: pupils studying computer science that volunteer to participate could be split into two groups, a control group, and a group with access to the Pseudocode compiler and online editor. Then, the following metrics could be measured and compared: the pupils' academic performance over the course of the school year, how many pupils from each group chose to take the Computer Science Baccalaureate Exam, what were the results they obtained in the aforementioned exam.

= Conclusions <conclusions>

// Un rezumat a ceea ce s-a facut, a contribuţiilor şi a rezultatelor

This work describes the design and development process of a compiler for a programming language which closely resembles the Pseudocode language used in Romanian high-school level computer science education. Thanks to LLVM, the compiler can produce performant executables, as well as executables enhanced with debugging metadata. It is expected that pupils struggling to understand the behavior of their code will benefit from being able to debug their code.

In addition to this, the work contributes an accessible, web-based Pseudocode editor. It is likely that the majority of pupils would interact with the Pseudocode language through this system.

All things considered, this work lays a foundation for improvement of pupils' Pseudocode development experience. The systems developed up to this point are in a usable state, however further testing and refinement is recommended, so as to bring them to the highest level of quality.

#pagebreak(weak: true)

#bibliography("works.bib")
